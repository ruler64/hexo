<!-- build time:Fri Aug 23 2024 15:57:47 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="icon" type="image/ico" sizes="32x32" href="/hexo/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Rulerの博客" href="https://ruler64.github.io/hexo/rss.xml"><link rel="alternate" type="application/atom+xml" title="Rulerの博客" href="https://ruler64.github.io/hexo/atom.xml"><link rel="alternate" type="application/json" title="Rulerの博客" href="https://ruler64.github.io/hexo/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/hexo/css/app.css?v=0.2.5"><meta name="keywords" content="后端,Docker"><link rel="canonical" href="https://ruler64.github.io/hexo/Docker%E5%AD%A6%E4%B9%A0/"><title>Docker 的学习 - 笔记 | Ruler's Blog = Ruler の博客 = 与天对弈，初心不改</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="reliefload"><span style="--i:0"></span> <span style="--i:1"></span> <span style="--i:2"></span> <span style="--i:3"></span> <span style="--i:4"></span> <span style="--i:5"></span> <span style="--i:6"></span></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline"><a href="/hexo/Docker%E5%AD%A6%E4%B9%A0" class="link external" itemprop="url">Docker 的学习<i class="ic i-link-alt"></i></a></h1><div class="meta"><span class="item" title="创建时间：2024-04-08 19:32:44"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-04-08T19:32:44+08:00">2024-04-08</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>12k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>11 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/hexo/" rel="start">Ruler's Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/008s4A3Tly8h7amfb8p38j31hc0u0n04.jpg"></li><li class="item" data-background-image="https://pic1.imgdb.cn/item/634fae1816f2c2beb1459e3b.jpg"></li><li class="item" data-background-image="https://s1.ax1x.com/2022/10/19/xsRmsP.png"></li><li class="item" data-background-image="https://pic1.imgdb.cn/item/634faf6216f2c2beb147f2ae.png"></li><li class="item" data-background-image="https://pic1.imgdb.cn/item/634fae3c16f2c2beb145cdf7.png"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/008s4A3Tly8h7alz4d1c4j31hc0u0n04.jpg"></li></ul></div><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div></header><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/hexo/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/hexo/categories/note/" itemprop="item" rel="index" title="分类于 笔记"><span itemprop="name">笔记</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="cn"><link itemprop="mainEntityOfPage" href="https://ruler64.github.io/hexo/Docker%E5%AD%A6%E4%B9%A0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/hexo/img/avatar.jpg"><meta itemprop="name" content="Ruler"><meta itemprop="description" content="与天对弈，初心不改, 路漫漫其修远兮，吾将上下而求索"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Ruler の博客"></span><div class="body md" itemprop="articleBody"><h1 id="快速入门"><a class="anchor" href="#快速入门">#</a> 快速入门</h1><h3 id="部署mysql"><a class="anchor" href="#部署mysql">#</a> 部署 MySQL</h3><p>首先，利用 Docker 来安装一个 MySQL 软件。使用 Docker 安装，仅仅需要一步即可，在命令行输入下面的命令（建议采用 CV 大法）：</p><figure class="highlight powershell"><figcaption data-lang="PowerShell"></figcaption><table><tr><td data-num="1"></td><td><pre>docker run <span class="token operator">-</span>d \</pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token operator">--</span>name mysql \</pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token operator">-</span>p 3306:3306 \</pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token operator">-</span>e TZ=Asia/Shanghai \</pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token operator">-</span>e MYSQL_ROOT_PASSWORD=123 \</pre></td></tr><tr><td data-num="6"></td><td><pre>  mysql</pre></td></tr></table></figure><p>MySQL 安装完毕！通过任意客户端工具即可连接到 MySQL</p><div class="note primary"><p>Docker 安装软件的过程，就是自动搜索下载镜像，然后创建并运行容器的过程。</p></div><p>Docker 会根据命令中的镜像名称自动搜索并下载镜像，Docker 官方提供了一个专门管理、存储镜像的网站，并对外开放了镜像上传、下载的权利。Docker 官方提供了一些基础镜像，然后各大软件公司又在基础镜像基础上，制作了自家软件的镜像，全部都存放在这个网站。这个网站就成了 Docker 镜像交流的社区：</p><p></p><div class="links"><div class="item" title="Docker" style="--block-color:#e9546b"><span class="exturl image" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS8=" data-background-image="https://cdn.jsdelivr.net/gh/ruler64/picture/picture/avater.jpg"></span><div class="info"><span class="exturl title" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS8=">hub.docker.com</span><p class="desc">Docker镜像交流社区</p></div></div></div><p></p><p>基本上我们常用的各种软件都能在这个网站上找到，我们甚至可以自己制作镜像上传上去。</p><p>像这种提供存储、管理 Docker 镜像的服务器，被称为 DockerRegistry，可以翻译为镜像仓库。DockerHub 网站是官方仓库，阿里云、华为云会提供一些第三方仓库，我们也可以自己搭建私有的镜像仓库。</p><p>官方仓库在国外，下载速度较慢，一般我们都会使用第三方仓库提供的镜像加速功能，提高下载速度。而企业内部的机密项目，往往会采用私有镜像仓库。</p><p>总之，镜像的来源有两种：</p><ul><li>基于官方基础镜像自己制作</li><li>直接去 DockerRegistry 下载</li></ul><h3 id="命令解读"><a class="anchor" href="#命令解读">#</a> 命令解读</h3><p>利用 Docker 快速的安装了 MySQL，非常的方便，不过我们执行的命令到底是什么意思呢？</p><figure class="highlight powershell"><figcaption data-lang="PowerShell"></figcaption><table><tr><td data-num="1"></td><td><pre>docker run <span class="token operator">-</span>d \</pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token operator">--</span>name mysql \</pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token operator">-</span>p 3306:3306 \</pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token operator">-</span>e TZ=Asia/Shanghai \</pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token operator">-</span>e MYSQL_ROOT_PASSWORD=123 \</pre></td></tr><tr><td data-num="6"></td><td><pre>  mysql</pre></td></tr></table></figure><p>解读：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ruler64/picture/picture/202404071611385.png" alt=""></p><ul><li><code>docker run -d</code> ：创建并运行一个容器， <code>-d</code> 则是让容器以后台进程运行</li><li><code>--name mysql</code> : 给容器起个名字叫 <code>mysql</code> ，你可以叫别的</li><li><code>-p 3306:3306</code> : 设置端口映射。<ul><li><strong>容器是隔离环境</strong>，外界不可访问。但是可以<strong>将宿主机端口映射容器内到端口</strong>，当访问宿主机指定端口时，就是在访问容器内的端口了。</li><li>容器内端口往往是由容器内的进程决定，例如 MySQL 进程默认端口是 3306，因此容器内端口一定是 3306；而宿主机端口则可以任意指定，一般与容器内保持一致。</li><li>格式： <code>-p 宿主机端口:容器内端口</code> ，示例中就是将宿主机的 3306 映射到容器内的 3306 端口</li></ul></li><li><code>-e TZ=Asia/Shanghai</code> : 配置容器内进程运行时的一些参数<ul><li>格式： <code>-e KEY=VALUE</code> ，KEY 和 VALUE 都由容器内进程决定</li><li>案例中， <code>TZ=Asia/Shanghai</code> 是设置时区； <code>MYSQL_ROOT_PASSWORD=123</code> 是设置 MySQL 默认密码</li></ul></li><li><code>mysql</code> : 设置<strong>镜像</strong>名称，Docker 会根据这个名字搜索并下载镜像<ul><li>格式： <code>REPOSITORY:TAG</code> ，例如 <code>mysql:8.0</code> ，其中 <code>REPOSITORY</code> 可以理解为镜像名， <code>TAG</code> 是版本号</li><li>在未指定 <code>TAG</code> 的情况下，默认是最新版本，也就是 <code>mysql:latest</code></li></ul></li></ul><p>镜像的名称不是随意的，而是要到 DockerRegistry 中寻找，镜像运行时的配置也不是随意的，要参考镜像的帮助文档，这些在 DockerHub 网站或者软件的官方网站中都能找到。</p><h1 id="docker基础"><a class="anchor" href="#docker基础">#</a> Docker 基础</h1><h3 id="常见命令"><a class="anchor" href="#常见命令">#</a> 常见命令</h3><p>可以参考官方文档：</p><p></p><div class="links"><div class="item" title="Docker" style="--block-color:#e9546b"><span class="exturl image" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9jbGkv" data-background-image="https://cdn.jsdelivr.net/gh/ruler64/picture/picture/avater.jpg"></span><div class="info"><span class="exturl title" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9jbGkv">Use the Docker command line</span><p class="desc">Docker's CLI command description and usage</p></div></div></div><p></p><h4 id="命令介绍"><a class="anchor" href="#命令介绍">#</a> 命令介绍</h4><p>其中，比较常见的命令有：</p><table><thead><tr><th style="text-align:center"><strong>命令</strong></th><th style="text-align:center"><strong>说明</strong></th><th style="text-align:center"><strong>文档地址</strong></th></tr></thead><tbody><tr><td style="text-align:center">docker pull</td><td style="text-align:center">拉取镜像</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9wdWxsLw==">docker pull</span></td></tr><tr><td style="text-align:center">docker push</td><td style="text-align:center">推送镜像到 DockerRegistry</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9wdXNoLw==">docker push</span></td></tr><tr><td style="text-align:center">docker images</td><td style="text-align:center">查看本地镜像</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9pbWFnZXMv">docker images</span></td></tr><tr><td style="text-align:center">docker rmi</td><td style="text-align:center">删除本地镜像</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9ybWkv">docker rmi</span></td></tr><tr><td style="text-align:center">docker run</td><td style="text-align:center">创建并运行容器（不能重复创建）</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9ydW4v">docker run</span></td></tr><tr><td style="text-align:center">docker stop</td><td style="text-align:center">停止指定容器</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9zdG9wLw==">docker stop</span></td></tr><tr><td style="text-align:center">docker start</td><td style="text-align:center">启动指定容器</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9zdGFydC8=">docker start</span></td></tr><tr><td style="text-align:center">docker restart</td><td style="text-align:center">重新启动容器</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9yZXN0YXJ0Lw==">docker restart</span></td></tr><tr><td style="text-align:center">docker rm</td><td style="text-align:center">删除指定容器</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9ybS8=">docs.docker.com</span></td></tr><tr><td style="text-align:center">docker ps</td><td style="text-align:center">查看容器</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9wcy8=">docker ps</span></td></tr><tr><td style="text-align:center">docker logs</td><td style="text-align:center">查看容器运行日志</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9sb2dzLw==">docker logs</span></td></tr><tr><td style="text-align:center">docker exec</td><td style="text-align:center">进入容器</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9leGVjLw==">docker exec</span></td></tr><tr><td style="text-align:center">docker save</td><td style="text-align:center">保存镜像到本地压缩文件</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9zYXZlLw==">docker save</span></td></tr><tr><td style="text-align:center">docker load</td><td style="text-align:center">加载本地压缩文件到镜像</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9sb2FkLw==">docker load</span></td></tr><tr><td style="text-align:center">docker inspect</td><td style="text-align:center">查看容器详细信息</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9pbnNwZWN0Lw==">docker inspect</span></td></tr></tbody></table><p>用一副图来表示这些命令的关系：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ruler64/picture/picture/202404071122855.png" alt=""></p><p>补充：</p><p>默认情况下，每次重启虚拟机我们都需要手动启动 Docker 和 Docker 中的容器。通过命令可以实现开机自启：</p><figure class="highlight powershell"><figcaption data-lang="PowerShell"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># Docker 开机自启</span></pre></td></tr><tr><td data-num="2"></td><td><pre>systemctl enable docker</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># Docker 容器开机自启</span></pre></td></tr><tr><td data-num="5"></td><td><pre>docker update <span class="token operator">--</span>restart=always <span class="token punctuation">[</span>容器名<span class="token operator">/</span>容器id<span class="token punctuation">]</span></pre></td></tr></table></figure><h4 id="演示"><a class="anchor" href="#演示">#</a> 演示</h4><p>以 Nginx 为例演示上述命令。</p><figure class="highlight powershell"><figcaption data-lang="PowerShell"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 第 1 步，去 DockerHub 查看 nginx 镜像仓库及相关信息</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 第 2 步，拉取 Nginx 镜像</span></pre></td></tr><tr><td data-num="4"></td><td><pre>docker pull nginx</pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment"># 第 3 步，查看镜像</span></pre></td></tr><tr><td data-num="7"></td><td><pre>docker images</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment"># 结果如下：</span></pre></td></tr><tr><td data-num="9"></td><td><pre>REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</pre></td></tr><tr><td data-num="10"></td><td><pre>nginx        latest    605c77e624dd   16 months ago   141MB</pre></td></tr><tr><td data-num="11"></td><td><pre>mysql        latest    3218b38490ce   17 months ago   516MB</pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment"># 第 4 步，创建并允许 Nginx 容器</span></pre></td></tr><tr><td data-num="14"></td><td><pre>docker run <span class="token operator">-</span>d <span class="token operator">--</span>name nginx <span class="token operator">-</span>p 80:80 nginx</pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token comment"># 第 5 步，查看运行中容器</span></pre></td></tr><tr><td data-num="17"></td><td><pre>docker <span class="token function">ps</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment"># 也可以加格式化方式访问，格式会更加清爽</span></pre></td></tr><tr><td data-num="19"></td><td><pre>&lt;<span class="token operator">!</span><span class="token operator">--</span>swig￼2-<span class="token operator">-</span>></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment"># 第 6 步，访问网页，地址：http:// 虚拟机地址</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token comment"># 第 7 步，停止容器</span></pre></td></tr><tr><td data-num="24"></td><td><pre>docker stop nginx</pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token comment"># 第 8 步，查看所有容器</span></pre></td></tr><tr><td data-num="27"></td><td><pre>&lt;<span class="token operator">!</span><span class="token operator">--</span>swig￼3-<span class="token operator">-</span>></pre></td></tr><tr><td data-num="28"></td><td><pre></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token comment"># 第 9 步，再次启动 nginx 容器</span></pre></td></tr><tr><td data-num="30"></td><td><pre>docker <span class="token function">start</span> nginx</pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token comment"># 第 10 步，再次查看容器</span></pre></td></tr><tr><td data-num="33"></td><td><pre>&lt;<span class="token operator">!</span><span class="token operator">--</span>swig￼4-<span class="token operator">-</span>></pre></td></tr><tr><td data-num="34"></td><td><pre></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token comment"># 第 11 步，查看容器详细信息</span></pre></td></tr><tr><td data-num="36"></td><td><pre>docker inspect nginx</pre></td></tr><tr><td data-num="37"></td><td><pre></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token comment"># 第 12 步，进入容器，查看容器内目录</span></pre></td></tr><tr><td data-num="39"></td><td><pre>docker exec <span class="token operator">-</span>it nginx bash</pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token comment"># 或者，可以进入 MySQL</span></pre></td></tr><tr><td data-num="41"></td><td><pre>docker exec <span class="token operator">-</span>it mysql mysql <span class="token operator">-</span>uroot <span class="token operator">-</span>p</pre></td></tr><tr><td data-num="42"></td><td><pre></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token comment"># 第 13 步，删除容器</span></pre></td></tr><tr><td data-num="44"></td><td><pre>docker <span class="token function">rm</span> nginx</pre></td></tr><tr><td data-num="45"></td><td><pre><span class="token comment"># 发现无法删除，因为容器运行中，强制删除容器</span></pre></td></tr><tr><td data-num="46"></td><td><pre>docker <span class="token function">rm</span> <span class="token operator">-</span>f nginx</pre></td></tr></table></figure><h4 id="命令别名"><a class="anchor" href="#命令别名">#</a> 命令别名</h4><p>下面是一些常用的 vim 命令：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">#进入编辑模式： i （在当前位置插入，开始编辑）；</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">#保存编辑文本： :w (英文冒号，保存当前编辑的文件）；</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">#退出编辑文件： :q（英文冒号，退出当前编辑的文件）；</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">#保存并退出： :wq （英文冒号，保存并退出当前编辑的文件）；</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">#强制退出：    :q! （英文冒号，强制退出不保存）。</span></pre></td></tr></table></figure><p>给常用 Docker 命令起别名，方便我们访问：</p><figure class="highlight powershell"><figcaption data-lang="PowerShell"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 修改 /root/.bashrc 文件</span></pre></td></tr><tr><td data-num="2"></td><td><pre>vi <span class="token operator">/</span>root/<span class="token punctuation">.</span>bashrc</pre></td></tr><tr><td data-num="3"></td><td><pre>内容如下：</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># .bashrc</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment"># User specific aliases and functions</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>alias <span class="token function">rm</span>=<span class="token string">'rm -i'</span></pre></td></tr><tr><td data-num="9"></td><td><pre>alias <span class="token function">cp</span>=<span class="token string">'cp -i'</span></pre></td></tr><tr><td data-num="10"></td><td><pre>alias <span class="token function">mv</span>=<span class="token string">'mv -i'</span></pre></td></tr><tr><td data-num="11"></td><td><pre>&lt;<span class="token operator">!</span><span class="token operator">--</span>swig￼5-<span class="token operator">-</span>></pre></td></tr><tr><td data-num="12"></td><td><pre>alias dis=<span class="token string">'docker images'</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment"># Source global definitions</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">-</span>f <span class="token operator">/</span>etc/bashrc <span class="token punctuation">]</span><span class="token punctuation">;</span> then</pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">.</span> <span class="token operator">/</span>etc/bashrc</pre></td></tr><tr><td data-num="17"></td><td><pre>fi</pre></td></tr></table></figure><p>然后，执行命令使别名生效</p><figure class="highlight powershell"><figcaption data-lang="PowerShell"></figcaption><table><tr><td data-num="1"></td><td><pre>source <span class="token operator">/</span>root/<span class="token punctuation">.</span>bashrc</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">#或者 source ~/.bashrc</span></pre></td></tr></table></figure><h3 id="数据卷"><a class="anchor" href="#数据卷">#</a> 数据卷</h3><p>容器是隔离环境；容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便。那么就产生了几个问题：</p><ul><li>如果要升级 MySQL 版本，需要销毁旧容器，那么数据岂不是跟着被销毁了？</li><li>MySQL、Nginx 容器运行后，如果我要修改其中的某些配置该怎么办？</li><li>我想要让 Nginx 代理我的静态资源怎么办？</li></ul><p>因此，容器提供程序的运行环境，但是<strong>程序运行产生的数据、程序运行依赖的配置都应该与容器解耦</strong>。</p><h4 id="什么是数据卷"><a class="anchor" href="#什么是数据卷">#</a> 什么是数据卷</h4><p><strong>数据卷（volume）<strong>是一个虚拟目录，是</strong>容器内目录</strong>与<strong>宿主机目录</strong>之间映射的桥梁。</p><p>以 Nginx 为例，我们知道 Nginx 中有两个关键的目录：</p><ul><li><code>html</code> ：放置一些静态资源</li><li><code>conf</code> ：放置配置文件</li></ul><p>如果我们要让 Nginx 代理我们的静态资源，最好是放到 <code>html</code> 目录；如果我们要修改 Nginx 的配置，最好是找到 <code>conf</code> 下的 <code>nginx.conf</code> 文件。</p><p>但遗憾的是，容器运行的 Nginx 所有的文件都在容器内部。所以我们必须利用数据卷将两个目录与宿主机目录关联，方便我们操作。如图：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ruler64/picture/picture/202404071856386.png" alt=""></p><p>在上图中：</p><ul><li>我们创建了两个数据卷： <code>conf</code> 、 <code>html</code></li><li>Nginx 容器内部的 <code>conf</code> 目录和 <code>html</code> 目录分别与两个数据卷关联。</li><li>而数据卷 conf 和 html 分别指向了宿主机的 <code>/var/lib/docker/volumes/conf/_data</code> 目录和 <code>/var/lib/docker/volumes/html/_data</code> 目录</li></ul><p>这样以来，容器内的 <code>conf</code> 和 <code>html</code> 目录就 与宿主机的 <code>conf</code> 和 <code>html</code> 目录关联起来，我们称为<strong>挂载</strong>。此时，我们操作宿主机的 <code>/var/lib/docker/volumes/html/_data</code> 就是在操作容器内的 <code>/usr/share/nginx/html/_data</code> 目录。只要我们将静态资源放入宿主机对应目录，就可以被 Nginx 代理了。</p><div class="note warning no-icon"><p>💡<strong>小提示</strong>：</p><p>​ <code>/var/lib/docker/volumes</code> 这个目录就是默认的存放所有容器数据卷的目录，其下再根据数据卷名称创建新目录，格式为 <code>/数据卷名/_data</code> 。</p><p>​	<strong>为什么不让容器目录直接指向宿主机目录呢</strong>？</p><ul><li>因为直接指向宿主机目录就与宿主机强耦合了，如果切换了环境，宿主机目录就可能发生改变了。由于容器一旦创建，目录挂载就无法修改，这样容器就无法正常工作了。</li><li>但是容器指向数据卷，一个逻辑名称，而数据卷再指向宿主机目录，就不存在强耦合。如果宿主机目录发生改变，只要改变数据卷与宿主机目录之间的映射关系即可。</li></ul><p>不过，我们通过由于数据卷目录比较深，不好寻找，通常我们也<strong>允许让容器直接与宿主机目录挂载而不使用数据卷</strong>，具体参考 2.2.3 小节。</p></div><h4 id="数据卷命令"><a class="anchor" href="#数据卷命令">#</a> 数据卷命令</h4><p>数据卷的相关命令有：</p><table><thead><tr><th style="text-align:center"><strong>命令</strong></th><th style="text-align:center"><strong>说明</strong></th><th style="text-align:center"><strong>文档地址</strong></th></tr></thead><tbody><tr><td style="text-align:center">docker volume create</td><td style="text-align:center">创建数据卷</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS92b2x1bWVfY3JlYXRlLw==">docker volume create</span></td></tr><tr><td style="text-align:center">docker volume ls</td><td style="text-align:center">查看所有数据卷</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS92b2x1bWVfbHMv">docs.docker.com</span></td></tr><tr><td style="text-align:center">docker volume rm</td><td style="text-align:center">删除指定数据卷</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS92b2x1bWVfcHJ1bmUv">docs.docker.com</span></td></tr><tr><td style="text-align:center">docker volume inspect</td><td style="text-align:center">查看某个数据卷的详情</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS92b2x1bWVfaW5zcGVjdC8=">docs.docker.com</span></td></tr><tr><td style="text-align:center">docker volume prune</td><td style="text-align:center">清除数据卷</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS92b2x1bWVfcHJ1bmUv">docker volume prune</span></td></tr></tbody></table><p>注意：容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p><p>演示一下 nginx 的 html 目录挂载</p><figure class="highlight powershell"><figcaption data-lang="PowerShell"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">#（可选）删除容器内若有 nginx 则要先删除，否则会冲突</span></pre></td></tr><tr><td data-num="2"></td><td><pre>docker <span class="token function">rm</span> <span class="token operator">-</span>f nginx</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 1. 首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">#在执行 docker run 命令时，使用 - v 数据卷：容器内目录可完成数据卷挂载</span></pre></td></tr><tr><td data-num="6"></td><td><pre>docker run <span class="token operator">-</span>d <span class="token operator">--</span>name nginx <span class="token operator">-</span>p 80:80 <span class="token operator">-</span>v html:<span class="token operator">/</span>usr/share/nginx/html nginx</pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment"># 2. 然后查看数据卷</span></pre></td></tr><tr><td data-num="9"></td><td><pre>docker volume <span class="token function">ls</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment"># 结果</span></pre></td></tr><tr><td data-num="11"></td><td><pre>DRIVER    VOLUME NAME</pre></td></tr><tr><td data-num="12"></td><td><pre>local     29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</pre></td></tr><tr><td data-num="13"></td><td><pre>local     html</pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment"># 3. 查看数据卷详情</span></pre></td></tr><tr><td data-num="16"></td><td><pre>docker volume inspect html</pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment"># 结果</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">[</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token string">"CreatedAt"</span>: <span class="token string">"2024-05-17T19:57:08+08:00"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token string">"Driver"</span>: <span class="token string">"local"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token string">"Labels"</span>: null<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token string">"Mountpoint"</span>: <span class="token string">"/var/lib/docker/volumes/html/_data"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token string">"Name"</span>: <span class="token string">"html"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token string">"Options"</span>: null<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token string">"Scope"</span>: <span class="token string">"local"</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token comment"># 4. 查看 /var/lib/docker/volumes/html/_data 目录</span></pre></td></tr><tr><td data-num="31"></td><td><pre>ll <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib/docker/volumes/html/_data</pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token comment"># 可以看到与 nginx 的 html 目录内容一样，结果如下：</span></pre></td></tr><tr><td data-num="33"></td><td><pre>总用量 8</pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token operator">-</span>rw-r-<span class="token operator">-</span>r-<span class="token operator">-</span><span class="token punctuation">.</span> 1 root root 497 12月 28 2021 50x<span class="token punctuation">.</span>html</pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token operator">-</span>rw-r-<span class="token operator">-</span>r-<span class="token operator">-</span><span class="token punctuation">.</span> 1 root root 615 12月 28 2021 index<span class="token punctuation">.</span>html</pre></td></tr><tr><td data-num="36"></td><td><pre></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token comment"># 5. 进入该目录，并随意修改 index.html 内容</span></pre></td></tr><tr><td data-num="38"></td><td><pre>cd <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>lib/docker/volumes/html/_data</pre></td></tr><tr><td data-num="39"></td><td><pre>vi index<span class="token punctuation">.</span>html</pre></td></tr><tr><td data-num="40"></td><td><pre></pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token comment"># 6. 打开页面，查看效果</span></pre></td></tr><tr><td data-num="42"></td><td><pre></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token comment"># 7. 进入容器内部，查看 /usr/share/nginx/html 目录内的文件是否变化</span></pre></td></tr><tr><td data-num="44"></td><td><pre>docker exec <span class="token operator">-</span>it nginx bash</pre></td></tr></table></figure><p>MySQL 会自动挂载数据卷：演示一下 MySQL 的匿名数据卷</p><figure class="highlight powershell"><figcaption data-lang="PowerShell"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 1. 查看 MySQL 容器详细信息</span></pre></td></tr><tr><td data-num="2"></td><td><pre>docker inspect mysql</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 关注其中.Config.Volumes 部分和.Mounts 部分</span></pre></td></tr></table></figure><p>我们关注两部分内容，第一是 <code>.Config.Volumes</code> 部分：</p><figure class="highlight json"><figcaption data-lang="JSON"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token property">"Config"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">//... 略</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token property">"Volumes"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token property">"/var/lib/mysql"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">//... 略</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以发现这个容器声明了一个本地目录，需要挂载数据卷，但是<strong>数据卷未定义</strong>。这就是匿名卷。</p><p>然后，我们再看结果中的 <code>.Mounts</code> 部分：</p><figure class="highlight json"><figcaption data-lang="JSON"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token property">"Mounts"</span><span class="token operator">:</span> <span class="token punctuation">[</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token property">"Type"</span><span class="token operator">:</span> <span class="token string">"volume"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token property">"Name"</span><span class="token operator">:</span> <span class="token string">"29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token property">"Source"</span><span class="token operator">:</span> <span class="token string">"/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token property">"Destination"</span><span class="token operator">:</span> <span class="token string">"/var/lib/mysql"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token property">"Driver"</span><span class="token operator">:</span> <span class="token string">"local"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token punctuation">]</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>可以发现，其中有几个关键属性：</p><ul><li>Name：数据卷名称。由于定义容器未设置容器名，这里的就是匿名卷自动生成的名字，一串 hash 值。</li><li>Source：宿主机目录</li><li>Destination : 容器内的目录</li></ul><p>上述配置是将容器内的 <code>/var/lib/mysql</code> 这个目录，与数据卷 <code>29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</code> 挂载。于是在宿主机中就有了 <code>/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data</code> 这个目录。这就是匿名数据卷对应的目录，其使用方式与普通数据卷没有差别。</p><p>接下来，可以查看该目录下的 MySQL 的 data 文件：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">ls</span> <span class="token parameter variable">-l</span> /var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data</pre></td></tr></table></figure><p>注意：每一个不同的镜像，将来创建容器后内部有哪些目录可以挂载，可以参考 DockerHub 对应的页面</p><h4 id="挂载本地目录或文件"><a class="anchor" href="#挂载本地目录或文件">#</a> 挂载本地目录或文件</h4><p>可以发现，数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 挂载本地目录</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token parameter variable">-v</span> 本地目录:容器内目录</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 挂载本地文件</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token parameter variable">-v</span> 本地文件:容器内文件</pre></td></tr></table></figure><div class="note warning"><p><strong>注意</strong>：本地目录或文件必须以 <code>/</code> 或 <code>./</code> 开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。</p></div><p>例如：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token parameter variable">-v</span> mysql:/var/lib/mysql <span class="token comment"># 会被识别为一个数据卷叫 mysql，运行时会自动创建这个数据卷</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token parameter variable">-v</span> ./mysql:/var/lib/mysql <span class="token comment"># 会被识别为当前目录下的 mysql 目录，运行时如果不存在会创建目录</span></pre></td></tr></table></figure><p>删除并重新创建 mysql 容器，并完成本地目录挂载：</p><ul><li>挂载 <code>/root/mysql/data</code> 到容器内的 <code>/var/lib/mysql</code> 目录</li><li>挂载 <code>/root/mysql/init</code> 到容器内的 <code>/docker-entrypoint-initdb.d</code> 目录（初始化的 SQL 脚本目录）</li><li>挂载 <code>/root/mysql/conf</code> 到容器内的 <code>/etc/mysql/conf.d</code> 目录（这个是 MySQL 配置文件目录）</li></ul><figure class="highlight powershell"><figcaption data-lang="PowerShell"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">#删除 mysql</span></pre></td></tr><tr><td data-num="2"></td><td><pre>docker <span class="token function">rm</span> <span class="token operator">-</span>f mysql</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">#切换到 /root 目录下</span></pre></td></tr><tr><td data-num="4"></td><td><pre>cd ~</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">#在 /root 目录下创建 mysql 目录</span></pre></td></tr><tr><td data-num="6"></td><td><pre>mkdir mysql</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">#切换到 /root/mysql 目录下</span></pre></td></tr><tr><td data-num="8"></td><td><pre>cd mysql/</pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">#创建相应的 data、conf、init 目录</span></pre></td></tr><tr><td data-num="10"></td><td><pre>mkdir <span class="token keyword">data</span></pre></td></tr><tr><td data-num="11"></td><td><pre>mkdir conf</pre></td></tr><tr><td data-num="12"></td><td><pre>mkdir init</pre></td></tr></table></figure><p><img data-src="https://cdn.jsdelivr.net/gh/ruler64/picture/picture/202404090812748.png" alt=""></p><p>接下来，本地目录挂载：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 1. 删除原来的 MySQL 容器</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> mysql</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 2. 进入 root 目录</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token builtin class-name">cd</span> ~</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment"># 3. 创建并运行新 mysql 容器，挂载本地目录</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token parameter variable">--name</span> mysql <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token parameter variable">-p</span> <span class="token number">3306</span>:3306 <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token parameter variable">-e</span> <span class="token assign-left variable">TZ</span><span class="token operator">=</span>Asia/Shanghai <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123</span> <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token parameter variable">-v</span> ./mysql/data:/var/lib/mysql <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token parameter variable">-v</span> ./mysql/conf:/etc/mysql/conf.d <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token parameter variable">-v</span> ./mysql/init:/docker-entrypoint-initdb.d <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="16"></td><td><pre>  mysql</pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment"># 4. 查看 root 目录，可以发现～/mysql/data 目录已经自动创建好了</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token function">ls</span> <span class="token parameter variable">-l</span> mysql</pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment"># 结果：</span></pre></td></tr><tr><td data-num="21"></td><td><pre>总用量 <span class="token number">4</span></pre></td></tr><tr><td data-num="22"></td><td><pre>drwxr-xr-x. <span class="token number">2</span> root    root   <span class="token number">20</span> <span class="token number">5</span>月  <span class="token number">19</span> <span class="token number">15</span>:11 conf</pre></td></tr><tr><td data-num="23"></td><td><pre>drwxr-xr-x. <span class="token number">7</span> polkitd root <span class="token number">4096</span> <span class="token number">5</span>月  <span class="token number">19</span> <span class="token number">15</span>:11 data</pre></td></tr><tr><td data-num="24"></td><td><pre>drwxr-xr-x. <span class="token number">2</span> root    root   <span class="token number">23</span> <span class="token number">5</span>月  <span class="token number">19</span> <span class="token number">15</span>:11 init</pre></td></tr></table></figure><p>这样即使删除 mysql 或者做升级，也不会丢失数据。</p><h3 id="镜像"><a class="anchor" href="#镜像">#</a> 镜像</h3><p>前面我们一直在使用别人准备好的镜像，那如果我要部署一个 Java 项目，把它打包为一个镜像该怎么做呢？</p><h4 id="镜像结构"><a class="anchor" href="#镜像结构">#</a> 镜像结构</h4><p>要想自己构建镜像，必须先了解镜像的结构。</p><p>镜像之所以能让我们快速跨操作系统部署应用而忽略其运行环境、配置，就是因为镜像中包含了程序运行需要的系统函数库、环境、配置、依赖。</p><p>因此，自定义镜像本质就是依次准备好程序运行的基础环境、依赖、应用本身、运行配置等文件，并且打包而成。</p><p>举个栗子，我们要从 0 部署一个 Java 应用，大概流程是这样：</p><ul><li>准备一个 linux 服务（CentOS 或者 Ubuntu 均可）</li><li>安装并配置 JDK</li><li>上传 Jar 包</li><li>运行 jar 包</li></ul><p>那因此，我们打包镜像也是分成这么几步：</p><ul><li>准备 Linux 运行环境（java 项目并不需要完整的操作系统，仅仅是基础运行环境即可）</li><li>安装并配置 JDK</li><li>拷贝 jar 包</li><li>配置启动脚本</li></ul><p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p><p>但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一 id，称为<strong> Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><p>例如，第一步中需要的 Linux 运行环境，通用性就很强，所以 Docker 官方就制作了这样的只包含 Linux 运行环境的镜像。我们在制作 java 镜像时，就无需重复制作，直接使用 Docker 官方提供的 CentOS 或 Ubuntu 镜像作为基础镜像。然后再搭建其它层即可，这样逐层搭建，最终整个 Java 项目的镜像结构如图所示：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ruler64/picture/picture/202404090843754.png" alt="img"></p><h4 id="dockerfile"><a class="anchor" href="#dockerfile">#</a> Dockerfile</h4><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以 Docker 就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给 Docker 去执行即可。</p><p>而这种记录镜像结构的文件就称为<strong> Dockerfile</strong>，其对应的语法可以参考官方文档：</p><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9idWlsZGVyLw==">https://docs.docker.com/engine/reference/builder/</span></p><p>其中的语法比较多，比较常用的有：</p><table><thead><tr><th style="text-align:center"><strong>指令</strong></th><th style="text-align:center"><strong>说明</strong></th><th style="text-align:center"><strong>示例</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>FROM</strong></td><td style="text-align:center">指定基础镜像</td><td style="text-align:center"><code>FROM centos:6</code></td></tr><tr><td style="text-align:center"><strong>ENV</strong></td><td style="text-align:center">设置环境变量，可在后面指令使用</td><td style="text-align:center"><code>ENV key value</code></td></tr><tr><td style="text-align:center"><strong>COPY</strong></td><td style="text-align:center">拷贝本地文件到镜像的指定目录</td><td style="text-align:center"><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td style="text-align:center"><strong>RUN</strong></td><td style="text-align:center">执行 Linux 的 shell 命令，一般是安装过程的命令</td><td style="text-align:center"><code>RUN yum install gcc</code></td></tr><tr><td style="text-align:center"><strong>EXPOSE</strong></td><td style="text-align:center">指定容器运行时监听的端口，是给镜像使用者看的</td><td style="text-align:center">EXPOSE 8080</td></tr><tr><td style="text-align:center"><strong>ENTRYPOINT</strong></td><td style="text-align:center">镜像中应用的启动命令，容器运行时调用</td><td style="text-align:center">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>例如，要基于 Ubuntu 镜像来构建一个 Java 应用，其 Dockerfile 内容如下：</p><figure class="highlight dockerfile"><figcaption data-lang="Docker"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 指定基础镜像</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token instruction"><span class="token keyword">FROM</span> ubuntu:16.04</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 配置环境变量，JDK 的安装目录、容器内时区</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token instruction"><span class="token keyword">ENV</span> JAVA_DIR=/usr/local</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token instruction"><span class="token keyword">ENV</span> TZ=Asia/Shanghai</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment"># 拷贝 jdk 和 java 项目的包</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token instruction"><span class="token keyword">COPY</span> ./jdk8.tar.gz <span class="token variable">$JAVA_DIR</span>/</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token instruction"><span class="token keyword">COPY</span> ./docker-demo.jar /tmp/app.jar</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment"># 设定时区</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token instruction"><span class="token keyword">RUN</span> ln -snf /usr/share/zoneinfo/<span class="token variable">$TZ</span> /etc/localtime &amp;&amp; echo <span class="token variable">$TZ</span> > /etc/timezone</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment"># 安装 JDK</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token instruction"><span class="token keyword">RUN</span> cd <span class="token variable">$JAVA_DIR</span> <span class="token operator">\</span></span></pre></td></tr><tr><td data-num="13"></td><td><pre> &amp;&amp; tar -xf ./jdk8.tar.gz <span class="token operator">\</span></pre></td></tr><tr><td data-num="14"></td><td><pre> &amp;&amp; mv ./jdk1.8.0_144 ./java8</pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment"># 配置环境变量</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token instruction"><span class="token keyword">ENV</span> JAVA_HOME=<span class="token variable">$JAVA_DIR</span>/java8</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token instruction"><span class="token keyword">ENV</span> PATH=<span class="token variable">$PATH</span>:<span class="token variable">$JAVA_HOME</span>/bin</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment"># 指定项目监听的端口</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token instruction"><span class="token keyword">EXPOSE</span> 8080</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment"># 入口，java 项目的启动命令</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token instruction"><span class="token keyword">ENTRYPOINT</span> [<span class="token string">"java"</span>, <span class="token string">"-jar"</span>, <span class="token string">"/app.jar"</span>]</span></pre></td></tr></table></figure><div class="note primary"><p>思考一下：以后我们会有很多很多 java 项目需要打包为镜像，他们都需要 Linux 系统环境、JDK 环境这两层，只有上面的 3 层不同（因为 jar 包不同）。如果每次制作 java 镜像都重复制作前两层镜像，是不是很麻烦。</p></div><p>所以，就有人提供了基础的系统加 JDK 环境，我们在此基础上制作 java 镜像，就可以省去 JDK 的配置了：</p><figure class="highlight dockerfile"><figcaption data-lang="Docker"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 基础镜像</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token instruction"><span class="token keyword">FROM</span> openjdk:11.0-jre-buster</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 设定时区</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token instruction"><span class="token keyword">ENV</span> TZ=Asia/Shanghai</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token instruction"><span class="token keyword">RUN</span> ln -snf /usr/share/zoneinfo/<span class="token variable">$TZ</span> /etc/localtime &amp;&amp; echo <span class="token variable">$TZ</span> > /etc/timezone</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment"># 拷贝 jar 包</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token instruction"><span class="token keyword">COPY</span> docker-demo.jar /app.jar</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment"># 入口</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token instruction"><span class="token keyword">ENTRYPOINT</span> [<span class="token string">"java"</span>, <span class="token string">"-jar"</span>, <span class="token string">"/app.jar"</span>]</span></pre></td></tr></table></figure><p>是不是简单多了。</p><h4 id="构建镜像"><a class="anchor" href="#构建镜像">#</a> 构建镜像</h4><p>当 Dockerfile 文件写好以后，就可以利用命令来构建镜像了。</p><p>我们准备好一个 demo 项目及对应的 Dockerfile：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ruler64/picture/picture/202404090851642.png" alt="img"></p><p>Dockerfile 中的样子：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ruler64/picture/picture/202404090859210.png" alt="image-20240409085911148"></p><p>首先，我们将 <code>docker-demo.jar</code> 包以及 <code>Dockerfile</code> 拷贝到虚拟机的 <code>/root/demo</code> 目录：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ruler64/picture/picture/202404090856731.png" alt="img"></p><p>然后，执行命令，构建镜像：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 进入镜像目录</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token builtin class-name">cd</span> /root/demo</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 开始构建</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">docker</span> build <span class="token parameter variable">-t</span> docker-demo:1.0 <span class="token builtin class-name">.</span></pre></td></tr></table></figure><p>命令说明：</p><ul><li><code>docker build</code> : 就是构建一个 docker 镜像</li><li><code>-t docker-demo:1.0</code> ： <code>-t</code> 参数是指定镜像的名称（ <code>repository</code> 和 <code>tag</code> ）</li><li><code>.</code> : 最后的点是指构建时 Dockerfile 所在路径，由于我们进入了 demo 目录，所以指定的是 <code>.</code> 代表当前目录，也可以直接指定 Dockerfile 目录：<ul><li><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 直接指定 Dockerfile 目录</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">docker</span> build <span class="token parameter variable">-t</span> docker-demo:1.0 /root/demo</pre></td></tr></table></figure></li></ul></li></ul><p>结果：</p><p><img data-src="https://cdn.jsdelivr.net/gh/ruler64/picture/picture/202404090905035.png" alt="image-20240409090510979"></p><p>查看镜像列表：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 查看镜像列表：</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">docker</span> images</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 结果</span></pre></td></tr><tr><td data-num="4"></td><td><pre>REPOSITORY    TAG       IMAGE ID       CREATED          SIZE</pre></td></tr><tr><td data-num="5"></td><td><pre>docker-demo   <span class="token number">1.0</span>       d6ab0b9e64b9   <span class="token number">27</span> minutes ago   327MB</pre></td></tr><tr><td data-num="6"></td><td><pre>nginx         latest    605c77e624dd   <span class="token number">16</span> months ago    141MB</pre></td></tr><tr><td data-num="7"></td><td><pre>mysql         latest    3218b38490ce   <span class="token number">17</span> months ago    516MB</pre></td></tr></table></figure><p>然后尝试运行该镜像：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 1. 创建并运行容器</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> <span class="token function">dd</span> <span class="token parameter variable">-p</span> <span class="token number">8080</span>:8080 docker-demo:1.0</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 2. 查看容器</span></pre></td></tr><tr><td data-num="4"></td><td><pre>dps</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment"># 结果</span></pre></td></tr><tr><td data-num="6"></td><td><pre>CONTAINER ID   IMAGE             PORTS                                                  STATUS         NAMES</pre></td></tr><tr><td data-num="7"></td><td><pre>78a000447b49   docker-demo:1.0   <span class="token number">0.0</span>.0.0:8080-<span class="token operator">></span><span class="token number">8080</span>/tcp, :::8090-<span class="token operator">></span><span class="token number">8090</span>/tcp              Up <span class="token number">2</span> seconds   <span class="token function">dd</span></pre></td></tr><tr><td data-num="8"></td><td><pre>f63cfead8502   mysql             <span class="token number">0.0</span>.0.0:3306-<span class="token operator">></span><span class="token number">3306</span>/tcp, :::3306-<span class="token operator">></span><span class="token number">3306</span>/tcp, <span class="token number">33060</span>/tcp   Up <span class="token number">2</span> hours     mysql</pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment"># 3. 访问</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">curl</span> localhost:8080/hello/count</pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment"># 结果：</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token operator">&lt;</span>h<span class="token operator"><span class="token file-descriptor important">5</span>></span>欢迎访问黑马商城, 这是您第1次访问<span class="token operator">&lt;</span>h<span class="token operator"><span class="token file-descriptor important">5</span>></span></pre></td></tr></table></figure><h3 id="网络"><a class="anchor" href="#网络">#</a> 网络</h3><p>我们创建了一个 Java 项目的容器，而 Java 项目往往需要访问其它各种中间件，例如 MySQL、Redis 等。现在，我们的容器之间能否互相访问呢？我们来测试一下</p><p>首先，我们查看下 MySQL 容器的详细信息，重点关注其中的网络 IP 地址：</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 1. 用基本命令，寻找 Networks.bridge.IPAddress 属性</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">docker</span> inspect mysql</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># 也可以使用 format 过滤结果</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token operator">&lt;</span><span class="token operator">!</span>--swig￼6--<span class="token operator">></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment"># 得到 IP 地址如下：</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token number">172.17</span>.0.2</pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment"># 2. 然后通过命令进入 dd 容器</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token function">dd</span> <span class="token function">bash</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment"># 3. 在容器内，通过 ping 命令测试网络</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token function">ping</span> <span class="token number">172.17</span>.0.2</pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment"># 结果</span></pre></td></tr><tr><td data-num="14"></td><td><pre>PING <span class="token number">172.17</span>.0.2 <span class="token punctuation">(</span><span class="token number">172.17</span>.0.2<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.</pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token number">64</span> bytes from <span class="token number">172.17</span>.0.2: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.053</span> ms</pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token number">64</span> bytes from <span class="token number">172.17</span>.0.2: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.059</span> ms</pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token number">64</span> bytes from <span class="token number">172.17</span>.0.2: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">3</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.058</span> ms</pre></td></tr></table></figure><p>发现可以互联，没有问题。</p><p>但是，容器的网络 IP 其实是一个虚拟的 IP，其值并不固定与某一个容器绑定，如果我们在开发时写死某个 IP，而在部署时很可能 MySQL 容器因为启动次序的变化导致其 IP 发生变化，连接会失败。</p><p>所以，我们必须借助于 docker 的网络功能来解决这个问题，官方文档：</p><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9uZXR3b3JrLw==">https://docs.docker.com/engine/reference/commandline/network/</span></p><p>常见命令有：</p><table><thead><tr><th style="text-align:center"><strong>命令</strong></th><th style="text-align:center"><strong>说明</strong></th><th style="text-align:center"><strong>文档地址</strong></th></tr></thead><tbody><tr><td style="text-align:center">docker network create</td><td style="text-align:center">创建一个网络</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9uZXR3b3JrX2NyZWF0ZS8=">docker network create</span></td></tr><tr><td style="text-align:center">docker network ls</td><td style="text-align:center">查看所有网络</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9uZXR3b3JrX2xzLw==">docs.docker.com</span></td></tr><tr><td style="text-align:center">docker network rm</td><td style="text-align:center">删除指定网络</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9uZXR3b3JrX3JtLw==">docs.docker.com</span></td></tr><tr><td style="text-align:center">docker network prune</td><td style="text-align:center">清除未使用的网络</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9uZXR3b3JrX3BydW5lLw==">docs.docker.com</span></td></tr><tr><td style="text-align:center">docker network connect</td><td style="text-align:center">使指定容器连接加入某网络</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9uZXR3b3JrX2Nvbm5lY3Qv">docs.docker.com</span></td></tr><tr><td style="text-align:center">docker network disconnect</td><td style="text-align:center">使指定容器连接离开某网络</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9uZXR3b3JrX2Rpc2Nvbm5lY3Qv">docker network disconnect</span></td></tr><tr><td style="text-align:center">docker network inspect</td><td style="text-align:center">查看网络详细信息</td><td style="text-align:center"><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9uZXR3b3JrX2luc3BlY3Qv">docker network inspect</span></td></tr></tbody></table><p>学习使用 “自定义网络 “</p><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 1. 首先通过命令创建一个网络</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">docker</span> network create hmall</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># 2. 然后查看网络</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">docker</span> network <span class="token function">ls</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment"># 结果：</span></pre></td></tr><tr><td data-num="7"></td><td><pre>NETWORK ID     NAME      DRIVER    SCOPE</pre></td></tr><tr><td data-num="8"></td><td><pre>639bc44d0a87   bridge    bridge    <span class="token builtin class-name">local</span></pre></td></tr><tr><td data-num="9"></td><td><pre>403f16ec62a2   hmall     bridge    <span class="token builtin class-name">local</span></pre></td></tr><tr><td data-num="10"></td><td><pre>0dc0f72a0fbb   <span class="token function">host</span>      <span class="token function">host</span>      <span class="token builtin class-name">local</span></pre></td></tr><tr><td data-num="11"></td><td><pre>cd8d3e8df47b   none      null      <span class="token builtin class-name">local</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment"># 其中，除了 hmall 以外，其它都是默认的网络</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment"># 3. 让 dd 和 mysql 都加入该网络，注意，在加入网络时可以通过 --alias 给容器起别名</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token comment"># 这样该网络内的其它容器可以用别名互相访问！</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token comment"># 3.1.mysql 容器，指定别名为 db，另外每一个容器都有一个别名是容器名</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token function">docker</span> network connect hmall mysql <span class="token parameter variable">--alias</span> db</pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment"># 3.2.db 容器，也就是我们的 java 项目</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token function">docker</span> network connect hmall <span class="token function">dd</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment"># 4. 进入 dd 容器，尝试利用别名访问 db</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token comment"># 4.1. 进入容器</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token function">dd</span> <span class="token function">bash</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token comment"># 4.2. 用 db 别名访问</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token function">ping</span> db</pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token comment"># 结果</span></pre></td></tr><tr><td data-num="27"></td><td><pre>PING db <span class="token punctuation">(</span><span class="token number">172.18</span>.0.2<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.</pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token number">64</span> bytes from mysql.hmall <span class="token punctuation">(</span><span class="token number">172.18</span>.0.2<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.070</span> ms</pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token number">64</span> bytes from mysql.hmall <span class="token punctuation">(</span><span class="token number">172.18</span>.0.2<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.056</span> ms</pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token comment"># 4.3. 用容器名访问</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token function">ping</span> mysql</pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token comment"># 结果：</span></pre></td></tr><tr><td data-num="33"></td><td><pre>PING mysql <span class="token punctuation">(</span><span class="token number">172.18</span>.0.2<span class="token punctuation">)</span> <span class="token number">56</span><span class="token punctuation">(</span><span class="token number">84</span><span class="token punctuation">)</span> bytes of data.</pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token number">64</span> bytes from mysql.hmall <span class="token punctuation">(</span><span class="token number">172.18</span>.0.2<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.044</span> ms</pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token number">64</span> bytes from mysql.hmall <span class="token punctuation">(</span><span class="token number">172.18</span>.0.2<span class="token punctuation">)</span>: <span class="token assign-left variable">icmp_seq</span><span class="token operator">=</span><span class="token number">2</span> <span class="token assign-left variable">ttl</span><span class="token operator">=</span><span class="token number">64</span> <span class="token assign-left variable">time</span><span class="token operator">=</span><span class="token number">0.054</span> ms</pre></td></tr></table></figure><p>OK，现在无需记住 IP 地址也可以实现容器互联了。</p><p><strong>总结</strong>：</p><ul><li>在自定义网络中，可以给容器起多个别名，默认的别名是容器名本身</li><li>加入自定义网络的容器才可以通过容器名互相访问</li></ul><div class="tags"><a href="/hexo/tags/%E5%90%8E%E7%AB%AF-Docker/" rel="tag"><i class="ic i-tag"></i> 后端,Docker</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-04-10 08:47:41" itemprop="dateModified" datetime="2024-04-10T08:47:41+08:00">2024-04-10</time> </span><span id="Docker学习/" class="item leancloud_visitors" data-flag-title="Docker 的学习" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/hexo/img/wechatpay.png" alt="Ruler 微信支付"><p>微信支付</p></div><div><img data-src="/hexo/img/alipay.png" alt="Ruler 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>作者： </strong>Ruler <i class="ic i-at"><em>@</em></i>Ruler の博客</li><li class="link"><strong>本文链接：</strong> <a href="https://ruler64.github.io/hexo/Docker%E5%AD%A6%E4%B9%A0/" title="Docker 的学习">https://ruler64.github.io/hexo/Docker学习/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/hexo/Docker%E5%AE%89%E8%A3%85/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclhfehz7j20zk0m8u0x.jpg" title="Docker的安装"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 笔记</span><h3>Docker的安装</h3></a></div><div class="item right"><a href="/hexo/Redis%E5%91%BD%E4%BB%A4/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;pic1.imgdb.cn&#x2F;item&#x2F;634fae3c16f2c2beb145cdf7.png" title="Redis命令"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 笔记</span><h3>Redis命令</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2mysql"><span class="toc-number">1.0.1.</span> <span class="toc-text">部署 MySQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A7%A3%E8%AF%BB"><span class="toc-number">1.0.2.</span> <span class="toc-text">命令解读</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#docker%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">Docker 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">2.0.1.</span> <span class="toc-text">常见命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.0.1.1.</span> <span class="toc-text">命令介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%94%E7%A4%BA"><span class="toc-number">2.0.1.2.</span> <span class="toc-text">演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%88%AB%E5%90%8D"><span class="toc-number">2.0.1.3.</span> <span class="toc-text">命令别名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">2.0.2.</span> <span class="toc-text">数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">2.0.2.1.</span> <span class="toc-text">什么是数据卷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%91%BD%E4%BB%A4"><span class="toc-number">2.0.2.2.</span> <span class="toc-text">数据卷命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E6%9C%AC%E5%9C%B0%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6"><span class="toc-number">2.0.2.3.</span> <span class="toc-text">挂载本地目录或文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F"><span class="toc-number">2.0.3.</span> <span class="toc-text">镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E7%BB%93%E6%9E%84"><span class="toc-number">2.0.3.1.</span> <span class="toc-text">镜像结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dockerfile"><span class="toc-number">2.0.3.2.</span> <span class="toc-text">Dockerfile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-number">2.0.3.3.</span> <span class="toc-text">构建镜像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">2.0.4.</span> <span class="toc-text">网络</span></a></li></ol></li></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/hexo/thread-lock/" rel="bookmark" title="线程安全问题">线程安全问题</a></li><li><a href="/hexo/SpringMvc-Rest/" rel="bookmark" title="深入SpringMvc学习之路（一）Rest风格开发">深入SpringMvc学习之路（一）Rest风格开发</a></li><li><a href="/hexo/Docker%E5%AE%89%E8%A3%85/" rel="bookmark" title="Docker的安装">Docker的安装</a></li><li class="active"><a href="/hexo/Docker%E5%AD%A6%E4%B9%A0/" rel="bookmark" title="Docker的学习">Docker的学习</a></li><li><a href="/hexo/Redis%E5%91%BD%E4%BB%A4/" rel="bookmark" title="Redis命令">Redis命令</a></li><li><a href="/hexo/Redis%E7%9A%84Java%E5%AE%A2%E6%88%B7%E7%AB%AF/" rel="bookmark" title="Redis的Java客户端">Redis的Java客户端</a></li><li><a href="/hexo/slam%E6%96%B9%E5%90%91/" rel="bookmark" title="slam方向">slam方向</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Ruler" data-src="/hexo/img/avatar.jpg"><p class="name" itemprop="name">Ruler</p><div class="description" itemprop="description">路漫漫其修远兮，吾将上下而求索</div></div><nav class="state"><div class="item posts"><a href="/hexo/archives/"><span class="count">9</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/hexo/categories/"><span class="count">3</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/hexo/tags/"><span class="count">8</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1bGVyNjQ=" title="https:&#x2F;&#x2F;github.com&#x2F;ruler64"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS94aS1zaGFuLXllLTM1" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;xi-shan-ye-35"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvcGxheWxpc3Q/aWQ9NzY2NTAyNDYzMg==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;playlist?id&#x3D;7665024632"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjEyNTI2OTc5OTFAcXEuY29t" title="mailto:1252697991@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/hexo/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/hexo/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/hexo/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/hexo/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/hexo/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item"><a href="/hexo/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li><li class="item"><a href="/hexo/statistics/" rel="section"><i class="ic i-clock"></i>统计</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/hexo/Docker%E5%AE%89%E8%A3%85/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/hexo/Redis%E5%91%BD%E4%BB%A4/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/hexo/categories/note/" title="分类于 笔记">笔记</a></div><span><a href="/hexo/Redis%E7%9A%84Java%E5%AE%A2%E6%88%B7%E7%AB%AF" title="Redis的Java客户端">Redis的Java客户端<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/hexo/categories/note/" title="分类于 笔记">笔记</a></div><span><a href="/hexo/Docker%E5%AD%A6%E4%B9%A0" title="Docker的学习">Docker的学习<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/hexo/categories/note/" title="分类于 笔记">笔记</a></div><span><a href="/hexo/thread-lock" title="线程安全问题">线程安全问题<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/hexo/categories/tools/" title="分类于 工具">工具</a></div><span><a href="/hexo/hexo-url-optimization" title="Hexo博客url优化">Hexo博客url优化<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/hexo/categories/note/" title="分类于 笔记">笔记</a></div><span><a href="/hexo/SpringMvc-Rest" title="深入SpringMvc学习之路（一）Rest风格开发">深入SpringMvc学习之路（一）Rest风格开发<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/hexo/categories/%E9%A1%B9%E7%9B%AE/" title="分类于 项目">项目</a></div><span><a href="/hexo/SpringBoot-MybatisPlus-page" title="MybatisPlus之分页查询">MybatisPlus之分页查询<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/hexo/categories/note/" title="分类于 笔记">笔记</a></div><span><a href="/hexo/Docker%E5%AE%89%E8%A3%85" title="Docker的安装">Docker的安装<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/hexo/categories/note/" title="分类于 笔记">笔记</a></div><span><a href="/hexo/slam%E6%96%B9%E5%90%91" title="slam方向">slam方向<i class="ic i-link-alt"></i></a></span></li><li class="item"><div class="breadcrumb"><a href="/hexo/categories/note/" title="分类于 笔记">笔记</a></div><span><a href="/hexo/Redis%E5%91%BD%E4%BB%A4" title="Redis命令">Redis命令<i class="ic i-link-alt"></i></a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Ruler @ Ruler's Blog</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">33k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">30 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"Docker学习/",favicon:{show:"✩•‿• ʜᴀᴠᴇ ᴀ ɢᴏᴏᴅ ᴛɪᴍᴇ☄︎♡",hide:"(っ◞‸◟c)浏览器崩溃！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//fastly.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js,npm/echarts@5.2.2/dist/echarts.min.js"></script><script src="/hexo/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->